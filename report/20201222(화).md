
프로그래머스 == level2 연습문제 최솟값 만들기
처음엔 바로 아래 문제처럼 풀었다. 근데, 타임오버가 떳다 아무래도 검사하고 또 검사하는 부분이 문제가 있는듯 하다. 그래서 그 밑의 풀이처럼 정렬을 한뒤 그냥 순서대로 곱하여 사용했다. 
</pre><code>#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

// A_len은 배열 A의 길이입니다.
// B_len은 배열 B의 길이입니다.
int solution(int A[], size_t A_len, int B[], size_t B_len) {
    int answer = 0;
    if(A_len !=B_len)
        return -1;
    int i = 0;
    int a = 0;
    int b = 0;
    int tmp_a[2] = {-1 , 0};
    int tmp_b[2] = {-1 , 0};
    int result = 0;
    int j;
    while(i < A_len)
    {
        tmp_a[0] = -1;
        tmp_b[0] = -1;
        j = 0;
        while(j < A_len)
        {
            if(j == 0)
            {
                tmp_a[0] = A[j];
                tmp_a[1] = 0;
            }
            else if(tmp_a[0] > A[j])
            {
                tmp_a[0] = A[j];
                tmp_a[1] = j;
            }
            if(j == 0)
            {
                tmp_b[0] = B[j];
                tmp_b[1] = 0;
            }
            else if(tmp_b[0] < B[j])
             {
                tmp_b[0] = B[j];
                tmp_b[1] = j;
            }
            j++;
        }
         result = result + tmp_a[0] *tmp_b[0];
        A[tmp_a[1]] = 1111; B[tmp_b[1]] = -1;
        i++;
    }
    answer = result;
    return answer;
}</pre></code>


<pre><code>#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

// A_len은 배열 A의 길이입니다.
// B_len은 배열 B의 길이입니다.
int compare(const void *a, const void *b)
{
    if(*(int *)a > *(int *)b)
        return(1);
    else if(*(int *)a < *(int *)b)
        return(-1);
    else return (0);
}
int solution(int A[], size_t A_len, int B[], size_t B_len) {
    int answer = 0;
    qsort(A,A_len, sizeof(int), compare);
    qsort(B,B_len, sizeof(int), compare);
    int result = 0;
    int i= 0;
    while(i < A_len)
    {
        result = result + A[i] * B[B_len - i -1];
        i++;
    }
    return result;
}</pre></code>





<pre><code>
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

int compare(const void *a, const void *b)
{
    int i =0;
    int j =0;
    int z = 0;
    char *tmp = (char *)malloc(sizeof(char) * 1000);
    char *tmp2 = (char *)malloc(sizeof(char) * 1000);
        while(((char **)a)[0][i])
        {
            tmp[z] = ((char **)a)[0][i];
            z++;
            i++;
        }
        int zz=0;
        while(((char **)b)[0][j])
        {
            tmp[z] = ((char **)b)[0][j];
            tmp2[zz] = ((char **)b)[0][j];
            z++;
            zz++;
                    j++;
        }
        tmp[z] = 0;
        j =0;
        while(((char **)a)[0][j])
        {
            tmp2[zz] = ((char **)a)[0][j];
            zz++;
                    j++;
        }
        tmp2[zz] = 0;
        long long int aa = atoi(tmp);
        long long int bb = atoi(tmp2);
        if(aa < bb)
            return(1);
        else if(aa> bb)
            return(-1);
        else return (0);

}
// numbers_len은 배열 numbers의 길이입니다.
char* solution(int numbers[], size_t numbers_len) {
    // return 값은 malloc 등 동적 할당을 사용해주세요. 할당 길이는 상황에 맞게 변경해주세요.
    char **save = (char **)malloc(sizeof(char *) * numbers_len + 1);
    save [numbers_len] = 0;
    int i = -1;
    while(++i < numbers_len)
        save[i] = (char *)malloc(sizeof(char) *300);
    i = -1;
    while(++i < numbers_len)
    {
        sprintf(save[i], "%d", numbers[i]); 
    }
    qsort(save, numbers_len, sizeof(char *), compare);
    char* answer = (char*)malloc(1999911);
    i =-1;
    int j = -1;
    long long z = 0;
    int qlen = 0;
    while(++i< numbers_len)
    {
        j = -1;
        qlen = strlen(save[i]);
        while(++j < qlen)
        {
            answer[z] = save[i][j];
            z++;
        }
    }
     answer[z] = 0;
    return answer;
}</pre></code>




문제 설명
문자열 s가 주어졌을 때 s에 포함된 알파벳 중 홀수개인 알파벳의 개수를 구하려고 합니다. 문자열 s에 포함된 알파벳 중에서 홀수 번 등장하는 알파벳의 개수를 return 하도록 solution 함수를 완성해주세요.

제한사항
문자열 s의 길이는 1 이상 10,000 이하입니다.
문자열 s는 알파벳 소문자로만 이루어져 있습니다.
입출력 예
s	result
aabbbccd	2
abebeaedeac	3
입출력 예 설명
입출력 예 #1
a가 2개, b가 3개, c가 2개, d가 1개이므로 홀수개인 알파벳은 b, d 2개입니다.

입출력 예 #2
a가 3개, b가 2개, c가 1개, d가 1개, e가 4개이므로 홀수개인 알파벳은 a, c, d 3개입니다.




문제 설명
자연수 수열이 주어질 때, 수열에서 같은 값이 연속해서 나오는 개수를 순서대로 나열하는 과정을 반복하려 합니다.

예를 들어 수열이 [1, 1, 3, 3, 2, 2, 4, 5, 1, 1, 1, 3, 3, 3]일 때, 같은 값이 연속해서 나오는 개수를 순서대로 나열하면 [2, 2, 2, 1, 1, 3, 3]이 됩니다. 새로 구한 수열에서 다시 같은 값이 연속해서 나오는 개수를 순서대로 나열하면 [3, 2, 2]가 됩니다. 마찬가지 작업을 계속 반복하면 수열은 다음과 같이 변합니다.

[3, 2, 2] → [1, 2] → [1, 1] → [2] → [1] → [1] → [1] ...

이와 같이 처음 주어진 수열에 같은 값이 연속해서 나오는 개수를 순서대로 나열하는 과정을 계속해서 수행하면 마지막에는 [1]이 무한히 반복됩니다.

초기 수열이 담긴 배열 arr가 매개변수로 주어질 때, 최초로 [1]이라는 수열이 나올때까지 과정을 몇 번 수행했는지 return 하도록 solution 함수를 완성해주세요.

제한사항
arr의 길이는 1 이상 1,000 이하입니다.
arr의 원소는 1 이상 1,000 이하인 자연수입니다.
입출력 예
arr	result
[1, 1, 3, 3, 2, 2, 4, 5, 1, 1, 1, 3, 3, 3]	6
[1,2,3]	3
[2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2, 1, 2]	5
[2]	1
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

다음과 같이 과정을 3번 수행하면 됩니다.

[1, 2, 3] → [1, 1, 1] → [3] → [1] ...

입출력 예 #3

다음과 같이 과정을 5번 수행하면 됩니다.

[2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2, 1, 2] → [2, 2, 2, 2, 3, 1, 1] → [4, 1, 2] → [1, 1, 1] → [3] → [1] ...

입출력 예 #4

다음과 같이 과정을 한 번만 수행하면 됩니다.

[2] → [1] ...






문제 설명
N개의 집이 원형으로 세워져 있는 마을이 있습니다. 각 집에는 1부터 N까지 순서대로 번호가 붙어 있습니다. 이 마을에서 바로 옆에 위치한 집으로 이동하는 데는 1 만큼의 단위 시간이 걸립니다. 또 집과 집 사이를 오가기 위해서는 중간에 위치한 집들을 반드시 거쳐서 이동해야 합니다. 다음은 N = 5인 경우의 예시입니다.
image
위 그림에서 1번 집에서 2번 집, 또는 5번 집으로 이동하는 데는 1의 시간이 소요됩니다. 또 1번 집에서 3번 집으로 이동하기 위해서는 시계방향으로 2번 집을 거쳐 가거나, 혹은 반시계방향으로 5번과 4번 집을 거쳐서 이동해야 합니다. 따라서 1번 집에서 3번 집으로 이동하는 데는 2 또는 3의 시간이 소요됩니다.
이 마을을 방문한 한 여행자가 현재 1번 집 앞에 있습니다. 이 여행자는 이 마을에 있는 모든 집을 미리 정해진 순서대로 방문하려고 합니다. 예를 들어 위 예시에서 여행자가 미리 방문하기로 한 집의 순서가 [1, 2, 3, 4, 5]라면 1번 집부터 시계방향으로 각 집을 방문하면 총 4의 단위 시간에 모든 집을 방문할 수 있습니다. 만약 미리 방문하기로 한 집의 순서가 [3, 5, 4, 1, 2]라면 다음과 같은 순서로 모든 집을 방문할 수 있습니다.

여행자는 처음에 1번 집 앞에 있으며, 시계방향으로 2번 집을 거쳐 3번 집으로 이동하면 2의 시간이 소요됩니다.
3번 집에서 시계방향으로 4번 집을 거쳐 5번 집으로 이동하면 2의 시간이 소요됩니다.
5번 집에서 반시계방향으로 4번 집으로 이동하면 1의 시간이 소요됩니다.
4번 집에서 시계방향으로 5번 집을 거쳐 1번 집으로 이동하면 2의 시간이 소요됩니다.
1번 집에서 시계방향으로 2번 집으로 이동하면 1의 시간이 소요됩니다.
위 방법대로 이동하면 총 8의 시간이 소요되며, 이때가 모든 집을 미리 정해진 순서대로 방문하는데 걸리는 시간의 최솟값이 됩니다.

마을에 원형으로 세워져 있는 집의 개수 N과 여행자가 모든 집을 방문하기 위해 미리 정해둔 순서가 들어있는 배열 sequence가 매개변수로 주어질 때, 여행자가 미리 정해둔 순서대로 모든 집을 방문하는 데 필요한 시간의 최솟값을 return 하도록 solution 함수를 완성해주세요.

제한 사항
N은 2 이상 1,000 이하의 자연수입니다.
여행자는 sequence에 들어있는 번호 순서대로 각 집을 방문합니다.
sequence의 길이는 N입니다.
sequence에는 중복된 숫자가 들어있지 않습니다. 즉, 모든 집은 반드시 한 번씩 방문하며, 같은 집을 두 번 이상 방문하지 않습니다.
시간은 집에서 집으로 이동하는데 걸리는 시간만 고려합니다.
입출력 예
N	sequence	result
5	[1,2,3,4,5]	4
5	[3,5,4,1,2]	8
입출력 예 설명
입출력 예 #1
문제의 예시와 같습니다.

입출력 예 #2
문제의 예시와 같습니다.



문제 설명
연속하는 자연수 두 개 이상을 곱해서 만들 수 있는 자연수를 크기 순으로 나열한 수열이 있습니다. 다음은 수열의 예시입니다.

2, 6, 12, 20, 24, 30, 42, 56, 60, 72 ...
예를 들어 2는 두 연속하는 자연수 1과 2를 곱해서 만들 수 있습니다. 마찬가지로 6 = 2 x 3 또는 6 = 1 x 2 x 3이며, 20 = 4 x 5, 60 = 3 x 4 x 5와 같이 연속하는 자연수를 두 개 이상 곱해서 만들 수 있습니다.

자연수 n이 매개변수로 주어질 때, 위 수열에서 n 번째 숫자를 return 하도록 solution 함수를 완성해주세요.

제한사항
n은 1 이상 1,000,000 이하인 자연수입니다.
정답이 1012 이하인 경우만 입력으로 주어집니다.
입출력 예
n	result
1	2
2	6
4	20
9	60
입출력 예 설명
문제에 주어진 수열에 따라 수열의 1,2,4,9 번째 값은 각각 2, 6, 20, 60입니다.


문제 설명
자연수 n을 이진법으로 변환했을 때 나오는 1의 개수를 k라고 했을 때, n보다 작은 자연수 중에서 이진법으로 변환하여 1의 개수가 k인 수가 몇 개 있는지를 return 하도록 solution 함수를 완성해 주세요.

제한사항
n은 1 ≤ n ≤ 230 인 자연수
입출력 예
n	result
9	3
입출력 예 설명
입출력 예 #1
n = 9인 경우 이진법으로 표현하면 1001로 1이 두 번 나옵니다. 9보다 작은 자연수 중 이진법으로 표현했을 때 1이 두 번 나오는 수는

3을 이진법으로 표현하면 11(2)
5를 이진법으로 표현하면 101(2)
6을 이진법으로 표현하면 110(2)
3개이므로 3을 반환하면 됩니다.



문제 설명
개구리 한 마리가 일렬로 놓인 징검다리 위를 뛰어가려고 합니다. 이 개구리는 첫 번째 위치의 징검다리 위에서 시작하여 가장 마지막 징검다리로 도달하기를 원하며, 각 징검다리 위에 쓰여 있는 숫자만큼만 징검다리를 건너뛸 수 있습니다. 각 징검다리에 쓰여 있는 숫자가 담긴 배열이 입력으로 주어질 때, 개구리가 마지막 징검다리에 도착하기 위한 최소 점프 횟수를 반환하는 함수 solution을 완성해 주세요. 만약 마지막 징검다리에 도착할 수 없다면 -1을 반환해 주세요.

제한사항
징검다리의 개수는 100,000 이하의 자연수입니다.
징검다리에 적힌 숫자는 0 이상 100 이하인 정수입니다.
입출력 예
nums	result
[4, 1, 2, 3, 1, 0, 5]	3
입출력 예 설명
입출력 예 #1
징검다리에 적힌 숫자는 [4, 1, 2, 3, 1, 0, 5]입니다.
0 번째 징검다리에서 4칸을 뛰어 4번째 징검다리에 온 다음 ,
4번째 징검다리에서 뒤쪽으로 한 칸 뛰어 3번째 징검다리로 간 후 ,
앞쪽으로 3칸을 뛰어 마지막 징검다리에 도착할 수 있으며 최소 점프 횟수는 3입니다.