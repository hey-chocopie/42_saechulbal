# 1. 학습 날짜

* 2020-07-28(화)

# 2. 학습시간

* 17:00 ~ 22:00(이노베이션 아카데임 클러스터)

# 3. 학습 범위 및 주제

* netwhat의 이해를 위한 문제 해석 및 ip에 대한 공부

# 4. 동료 학습 방법

해당 사항 없음.

# 5. 학습 목표

* network에 대한 이해와 공부.

# 6. 상세 학습 내용
* 실제 코딩한 시간 0시간

- Netwhat 참고자료.

과제 해석(kchoi님): [https://42kchoi.tistory.com/21?category=887188](https://42kchoi.tistory.com/21?category=887188)
시험 팁(kchoi님): [https://42kchoi.tistory.com/category/Code%2042/Netwhat](https://42kchoi.tistory.com/category/Code%2042/Netwhat)
연습문제 정리(daelee님): [https://velog.io/@hidaehyunlee/Netwhat-연습문제-정리](https://velog.io/@hidaehyunlee/Netwhat-연습문제-정리)
					(연습문제도 좋지만 선행지식 부분에서 정리를 정말 잘 해주셨음)

- 목차: 클릭하면 각 내용으로 연결됨. (참고: 정리하다 말았음.)

😃

- ip adress란?

컴퓨터 네트워크에서 장치들이 서로를 인식하고 통신을 하기위해서 허용한다.
인터넷에서 사용하는 전화번호라고 생각할수 잇다. 5036이나 5047
오늘날 주로 사용되고 있는  ip주소는 ip버전 4주소이나 이 주소가 부족해짐에 따라 길이를 늘린 ip 6주소가 널리 사용되는 추세이다.

- ip version4 주소, 이 주소의 범위는 32비트로 보통 0~255 사이의 십진수 넷으로 구분하여 나타낸다. 0.0.0.0 부터 255.255.255.255까지 가능하며 42억9497만7296개의 ip가 존재한다. 중간에 일부 특별한 기능을 가진 주소가 있는데, 127.0.0.1은 localhost자기 자신을 가리킨다.
- Internet protocol의 줌말.

protocol이란?, 프로토콜
통신 프로토콜 또는 통신 규약은 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계이다. 통신 프로토콜은 신호 체계, 인증, 그리고 오류 감지 및 수정 기능을 포함할 수 있다. 프로토콜은 형식, 의미론, 그리고 통신의 동기 과정 등을 정의하기는 하지만 구현되는 방법은 독립적이다. 따라서 프로토콜은 하드웨어 또는 소프트웨어 그리고 때로는 모두를 사용하여 구현되기도 한다.
 시스템은 일반적으로 단일 프로토콜을 사용하여 전송을 처리하지 않는다. 대신 프로토콜 스위트(protocol suite)라 불리는 일련의 협력 프로토콜을 사용한다. 가장 잘 알려진 프로토콜 제품군은 tcp / ip , ipx/ spx/ spx, x.25 , ax.25 alc appletalk이다.

프로토콜은 두 가지로 이루어져 있으며 물리적 측면과 논리적 측면으로 나뉜다.
물리적 측면: 자료전송에 쓰이는 전송 매체, 접속용 단자 및 전송 신호, 회선 규격 등
논리적 측면: 프레임(frame, 자료의 표현 형식 단위) 구성, 프레임 안에 있는 각 항목의 뜻과 기능, 자료 전송의 절차 등.
폐쇄적인 프로토콜 : 자사 장치들끼리 통신하기 위한 독자적인 통신 규약이며, 자세한 규격이 공개되어 있지 않아서 크래킹 위협에서 상대적으로 안전하다.(보기 : ibm의 sna, sdlc 프로토콜)
공개된 프로토콜 : 여러장치들에 쓰이는 널리 알려진 규격이며, 규격이 널리 공개되어 있기 떄문에 컴퓨터와 네트워크 크래킹에 취약한 편이다. (보기: 인터넷의 tcp/ip)

인터넷 프로토콜 스위트와 tcp / ip
인터넷 프로토콜 스위트 (영어: internet protocol suite)는 인터넷에서 컴퓨터들이 서로 정보를 주고 받는데 쓰이는 통신규약(프로토콜)의 모음이다. 인터넷 프로토콜 슈트 중 tcp와 ip가 가장 많이 쓰이기 떄문에 tcp/ip 프로토콜 슈트라고도 불린다.

tcp/ip 는 패킷 통신 방식의 인터넷 프로토콜인 ip(인터넧넷 프로토콜)와 전송 조절 프로토콜인 tcp(전송 제어 프로토콜)로 이루어져있다. ip 는 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서와 받는 순서가 다를 수 있다. (unreable datagram service)tcp는 ip위에서 동작하는 프로토콜, 데이터의 전달을 보증하고 보낸 순서대로 받게 해준다. http, ftp, smtp 등 tcp를 기반으로 한 많은 수의 애플리케이션 프로토콜들이 ip 위에서  동작하기 떄문에, 묶어서 tcp/ip로 부르기도 한다.

TCP
**전송 제어 프로토콜(Transmission Control Protocol, TCP)**은 인터넷 프로토콜 스위트(IP)의 핵심 프로토콜 중 하나로, IP와 함께 TCP/IP라는 명칭으로도 널리 불린다. TCP는 근거리 통신망이나 인트라넷, 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 [옥텟](https://www.notion.so/Netwhat-600e0484af3a4873a41f8ec786494d4f#be185cc467bd42a8aac7920cd87bdb18)을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다. **TCP는 전송 계층에 위치**한다. 네트워크의 정보 전달을 통제하는 프로토콜이자 인터넷을 이루는 핵심 프로토콜의 하나로서 국제 인터넷 표준화 기구(IETF)의 RFC 793에 기술되어 있다.
TCP는 웹 브라우저들이 월드 와이드 웹에서 서버에 연결할 때 사용되며, 이메일 전송이나 파일 전송에도 사용된다.

TCP의 안정성을 필요로 하지 않는 애플리케이션의 경우 일반적으로 TCP 대신 **비접속형 사용자 데이터그램 프로토콜(User Datagram Protocol, [UDP](https://www.notion.so/Netwhat-600e0484af3a4873a41f8ec786494d4f#5639ae1ebc8840009f26d6c09c939f2d))**을 사용한다. 이것은 전달 확인 및 순차 보장 기능이 없는 대신 [오버헤드](https://www.notion.so/Netwhat-600e0484af3a4873a41f8ec786494d4f#3b508cdf58ff4d738c773779c3ac9a9a)가 작고 지연시간이 짧다는 장점이 있다.
(출처: [https://ko.wikipedia.org/wiki/전송_제어_프로토콜](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C))

**UDP ([vs TCP 차이 자세히 알아보기](https://velog.io/@hidaehyunlee/TCP-%EC%99%80-UDP-%EC%9D%98-%EC%B0%A8%EC%9D%B4))**
**사용자 데이터그램 프로토콜(User Datagram Protocol, UDP)**은 인터넷 프로토콜 스위트의 주요 프로토콜 가운데 하나이다. 유니버설 데이터그램 프로토콜(Universal Datagram Protocol)이라고 일컫기도 한다.
**UDP의 전송 방식은 너무 단순**해서 서비스의 신뢰성이 낮고, 데이터그램 도착 순서가 바뀌거나, 중복되거나, 심지어는 통보 없이 누락시키기도 한다. UDP는 일반적으로 오류의 검사와 수정이 필요 없는 애플리케이션에서 수행할 것으로 가정한다.
UDP를 사용하는 네트워크 애플리케이션에는 도메인 이름 서비스 (DNS), IPTV, 음성 인터넷 프로토콜 (VoIP), TFTP, IP 터널, 그리고 많은 온라인 게임 등이 있다.

**TCP**는 데이터를 주고 받을 양단 간에 **먼저 연결을 설정**하고 설정된 연결을 통해 **양방향**으로 데이터를 전송하지만, **UDP**는 **연결을 설정하지 않고** 수신자가 데이터를 받을 준비를 확인하는 단계를 거치지 않고 **단방향**으로 정보를 전송한다.
**신뢰성** - TCP는 메시지 수신을 확인하지만 UDP는 수신자가 메시지를 수신했는지 확인할 수 없다.
**순서 정렬** - TCP에서는 메시지가 보내진 순서를 보장하기 위해 재조립하지만 UDP는 메시지 도착 순서를 예측할 수 없다.
**부하** - TCP보다 속도가 일반적으로 빠르고 [오버헤드](https://www.notion.so/Netwhat-600e0484af3a4873a41f8ec786494d4f#3b508cdf58ff4d738c773779c3ac9a9a)가 적다.
(출처: [https://ko.wikipedia.org/wiki/사용자_데이터그램_프로토콜](https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%A9%EC%9E%90_%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C))

+ TCP는 연결을 설정하고 양방향으로 통신하므로 **유니캐스트(unicast, 일대일)** 방식을 이용하며, UDP는 수신자의 수신 상태를 확인하지 않고 데이터를 전송하므로 **브로드캐스트(broadcast, 일대다)**방식을 이용하여 송신할 수 있다. (브로드캐스팅은 멀티캐스팅에 포함되는 개념)
- 참고: [http://blog.naver.com/PostView.nhn?blogId=kbm0996&logNo=221045822230&categoryNo=92&parentCategoryNo=0&viewDate=&currentPage=1&postListTopCurrentPage=1&from=postView](http://blog.naver.com/PostView.nhn?blogId=kbm0996&logNo=221045822230&categoryNo=92&parentCategoryNo=0&viewDate=&currentPage=1&postListTopCurrentPage=1&from=postView)

**IP address의 class** ([링크](https://velog.io/@hidaehyunlee/IP-address%EB%9E%80#2-ip%EC%A3%BC%EC%86%8C%EC%9D%98-%ED%81%B4%EB%9E%98%EC%8A%A4abc-class%EB%9E%80))
**클래스 도입 이전,** 원래 32비트 IPv4 주소는 호스트가 연결되어있는 특정 네트워크를 가리키는 단순히 8비트의 네트워크 영역과 해당 네트워크 내에서 호스트의 주소를 가리키는 나머지 영역으로 단순하게 구분되어 있었다. 참고로 이 형태는 랜 도입 이전에 정해졌는데, 이때는 ARPANET과 같은 적은 수의 대규모 네트워크밖에 없었다.
(출처: [https://ko.wikipedia.org/wiki/네트워크_클래스](https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%ED%81%B4%EB%9E%98%EC%8A%A4))

공통적인 부분(중복이 있는)은 **네트워크 주소**이고, 식별할 수 있는 부분(중복이 없고 유일무이한)은 **호스트 주소**라고 할 수 있다. 하나의 네트워크 안에서 IP는 네트워크 영역은 같아야하고, 호스트 영역은 서로 달라야 통신이 가능하다.
**클래스**는 하나의 IP주소에서 네트워크 영역과 호스트 영역을 나누는 방법이자, 약속이다. IP주소를 3개의 클래스로 나누는 이유는 네트워크 크기에 따른 구분이라 생각하면 쉽다. 하나의 네트워크에서 몇 개의 호스트 IP까지 가질 수 있는가에 따라서 클래스를 나눌 수 있다. 즉, 네트워크 범위가 커질수록 호스트 주소 범위는 작아지는 반비례 관계이다.
IP주소 클래스는 총 5개가 있다. A클래스, B클래스, C클래스, D클래스 E클래스. 하지만 보통 A, B, C 3개 정도만 알고있으면 충분하다. (나머지 D, E 클래스는 멀티캐스트용, 연구용으로 사용)

**A클래스**는 하나의 네트워크가 가질 수 있는 호스트 수가 제일 많은 클래스이다. IP주소를 32자리 2진수로 표현했을때, **맨 앞자리 수가 항상 0** 인 경우가 바로 A클래스이다. 즉 0xxx xxxx. xxxx xxxx. xxxx xxxx. xxxx xxxx 와 같이 되어있다. x 는 0 또는 1. 이 범위를 10진수로 표현하면 **0**.0.0.0 ~ **127**.255.255.255 이다.
그런데 A클래스에서 네트워크 주소는 1.0.0.0 ~ 126.0.0.0 까지로 규정되어있다. 약속이다. 그래서 IP주소 중 **1부터 126으로 시작하는 네트워크**는 A클래스라고 생각하면 된다.
**호스트 주소가 가질 수 있는 갯수**는 (2^24) **- 2개** 이다. (-2 이유는 모두가 1인경우 브로드캐스트 주소로 사용하고 모두 0인 경우엔 네트워크 주소로 사용하기 때문) 예를 들어 A클래스로 13.0.0.0 네트워크 주소를 할당 받았을 때, 가능한 호스트 IP를 10진수로 나타내면 13.0.0.0 ~ 13.255.255.255 가 될 것이다. 하지만 여기서 13.**0.0.0** 은 **네트워크 주소를 표현**하기 위해서 호스트IP로 사용하면 안된다. 또, 13.**255.255.255** 역시 **브로드캐스트 주소로 사용**하기 때문에 호스트 IP로 사용하면 안된다. **따라서 (2^24) - 2** 를 해주는 것이다.

**B클래스**의 IP주소를 32자리 2진수로 표현했을때, **맨 앞자리 수는 항상 10** 이여야 한다. 즉 10xx xxxx. xxxx xxxx. xxxx xxxx. xxxx xxxx. 이 범위를 10진수로 표현하면 **128.**0.0.0 ~ **191**.255.255.255 . 네트워크 주소 범위는 10xx xxxx. xxxx xxxx 에서 x들이 가질 수 있는 경우의 수, **2^14** 개 이고, 호스트 주소 범위는 xxxx xxxx. xxxx xxxx 에서 x들의 경우의 수인 **(2^16) - 2** 개 이다.

**C클래스**의 IP주소는 2진수로 표현했을 때 **반드시 110으로 시작**한다. 즉 110x xxxx. xxxx xxxx. xxxx xxxx. xxxx xxxx. 이 범위를 10진수로 표현하면 **192**.0.0.0 ~ **223**.255.255.255. 네트워크 범위는 110x xxxx. xxxx xxxx. xxxx xxxx 에서 x들이 가질 수 있는 경우의 수, **2^21** 개 이고, 호스트 주소 범위는 xxxx xxxx 에서 x들이 가질 수 있는 경우의 수, **(2^8 )-2** 개 이다.
(출처: [https://velog.io/@hidaehyunlee/IP-address%EB%9E%80](https://velog.io/@hidaehyunlee/IP-address%EB%9E%80))

**클래스	앞선 비트	시작주소**		**끝주소**		**해당 [사이더](https://www.notion.so/Netwhat-600e0484af3a4873a41f8ec786494d4f#91ce74dcae45422fb42b1142d7d5ee19) 블록
클래스 A**	    **0**			**0**.0.0.0		**127**.255.255.255	    /8
**클래스 B**	    **10**			**128**.0.0.0		**191**.255.255.255	    /16
**클래스 C**	    **110**		**192**.0.0.0		**223**.255.255.255	    /24
**클래스 D**	    1110		224.0.0.0		239.255.255.255	    NA
**클래스 E**	    1111		240.0.0.0		255.255.255.255	    NA

클래스 A: **0**nnnnnnn.hhhhhhhh.hhhhhhhh.hhhhhhhh
클래스 B: **10**nnnnnn.nnnnnnnn.hhhhhhhh.hhhhhhhh
클래스 C: **110**nnnnn.nnnnnnnn.nnnnnnnn.hhhhhhhh
(n: 네트워크 주소, h: 호스트 주소)

오늘날 IP 주소와 함께 널리 사용되는 IP 주소 **[넷마스크](https://www.notion.so/Netwhat-600e0484af3a4873a41f8ec786494d4f#3fb2989abfc042b39faa5d02ad8cd30b)**는 필요없었는데, 이는 마스크의 길이가 순전히 IP 주소로부터 판별 가능했기 때문이다. 즉, 누구라도 IP의 첫 몇 비트만 보면 어떠한 클래스에 속하는지 알 수 있었기 때문이다.
하지만, 이러한 첫 번째의 변화는 오래가지 못했다. IP 주소 부족은 여전히 계속되었다. 가장 큰 문제는 대부분의 사이트들은 "클래스 C"에 들어가기에는 너무 컸고, 대신 "클래스 B"를 할당받았다. 인터넷의 빠른 발전과 함께, 클래스 B의 가능한 주소는(기본적으로 2^14, 즉 약 16,000개) 급속도로 소진되어 갔다. 이러한 문제 및 다른 여러 문제를 해결하기 위해 1993년경부터 네트워크 클래스는 **[사이더](https://www.notion.so/Netwhat-600e0484af3a4873a41f8ec786494d4f#91ce74dcae45422fb42b1142d7d5ee19)**(=CIDR)에 의해 대체되게 되었다.
(출처: [https://ko.wikipedia.org/wiki/네트워크_클래스](https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%ED%81%B4%EB%9E%98%EC%8A%A4))

- Netmask란?

넷마스크란 IP 주소의 네트웍 부분을 가리거나 걸러서 호스트 컴퓨터의 주소 부분만이 남도록 하기 위해 0과 1이 조합되어 있는 문자열이다.

넷마스크의 형태, 네트워크 주소 부분을 1로 치환한 모양
—-네크워크 주소——-호스트
     203.  0.   113.       43
     255.255.255.       0

**넷 마스크**
요즘에는 뚜렷하게 **넷마스크와 서브넷마스크를 구분하지 않는다고 한다. 왜냐면 이후(현재) subnet mask만 쓰고 있기 때문이다.
(출처: [https://velog.io/@hidaehyunlee/넷마스크Netmask와-서브넷마스크Subnetmask](https://velog.io/@hidaehyunlee/넷마스크Netmask와-서브넷마스크Subnetmask))

**부분망(Subnetwork)** 또는 **부분망 마스크(IP Subnet Mask, IP 서브넷 마스크)**, IP 서브넷은 인터넷 프로토콜 스위트의 가시적인 부분이다.
**부분망을 구하는 과정**은 한 주소의 네트워크 및 부분망 부분과 호스트 식별자를 구분하는 일을 포함한다. 이는 IP 주소 및 (부분)망 마스크 간 **AND 비트 연산**을 통해 수행한다. 이를 통해 네트워크 주소나 **접두사(prefix)**가 만들어지며 나머지는 호스트 식별자가 된다.

**IPv6** 주소 공간의 설계는 IPv4와는 상당히 다르다. IPv4에서의 서브네팅의 주 이유는 특히 기업과 같은 곳에서 상대적으로 작은 주소 공간을 효율적으로 이용할 수 있게 하기 위함이다. IPv6는 커다란 주소 공간을 이용할 수 있으므로 최종 사용자들에게까지도 이러한 **제약이 존재하지 않는다**.

*여기서 참고 :* [https://www.it-swarm-ko.tech/ko/networking/ipv6-서브넷은-어떻게-작동하며-ipv4-서브넷과-어떻게-다릅니-까/960177063/](https://www.it-swarm-ko.tech/ko/networking/ipv6-서브넷은-어떻게-작동하며-ipv4-서브넷과-어떻게-다릅니-까/960177063/)

**IPv4 네트워크 마스크**는 **32비트**로 이루어져 있으며 일련의 숫자 0이 1들의 블록을 따른다. 뒷따르는 0들의 블록은 **호스트 식별자**의 일부임을 지시한다.
				**이진 형태								닷 데시멀 노테이션**
**IP 주소**			11000000.10101000.00000101.10000010	**192.168.5.**130
**서브넷 마스크**			11111111.11111111.11111111.00000000		**255.255.255.**0
**네트워크 접두사**		11000000.10101000.00000101.00000000	**192.168.5.**0
**호스트 부분**		00000000.00000000.00000000.10000010	0.0.0.**130**
(출처: [https://ko.wikipedia.org/wiki/부분망](https://ko.wikipedia.org/wiki/부분망))

전체적으로  net mask는 호스트만 남겨주기 위해 사용하는 이진수 개념이고,

subnet 과 netmask의 차이. https://kldp.org/node/127933

- subnet 과 netmask의 차이. https://kldp.org/node/127933
- 192.168.1.1/25 서브넷
192.168.1.1/24 넷마스크
192.168.1.1/23 수퍼넷

![Alt text]([https://juner417.github.io/assets/post_images/2018-03-23-network-101-ip-subnet/netmask.png](https://juner417.github.io/assets/post_images/2018-03-23-network-101-ip-subnet/netmask.png))

![https://juner417.github.io/assets/post_images/2018-03-23-network-101-ip-subnet/netmask.png](https://juner417.github.io/assets/post_images/2018-03-23-network-101-ip-subnet/netmask.png)

- subnet의 Broadcast 주소

우선 브로드캐스팅이라는 의미를 이해해야함.
브로드캐스팅(broadcasting)은 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식을 의미한다.
인데 여기서 네트워크에 연결된 모든 호스트의 범위를 구하기 위해 사용되는게 bradcast주소이다.

구하는 방법.
내 컴퓨터의 IP주소가 165.132.120.10 이고,
서브넷마스크가 255.255.252.0 이라고 가정하자.

IP주소와 서브넷마스크를 비트 AND 연산을 수행하면 네트워크주소를 얻을 수 있다.
10100101 10000100 01111000 01100100
11111111 11111111 11111100 00000000
---------------------------------------------------------

10100101 10000100 01111000 00000000 <- 이것이 네트워크 주소 즉, 165.132.120.0 이다
얻어진 네트워크 주소에서 서브넷마스크의 0으로된 비트를 모두 1로 바꾸어주면 브로드캐스트 주소를 얻을 수있다.
10100101 10000100 01111000 00000000 (네트워크주소) 에서 마지막 10개 비트(서브넷에서의 0에 해당하는 비트)를 1로 바꾸면,
10100101 10000100 01111011 11111111 <- 이것이 브로드캐스트 주소 즉, 165.132.123.255 이다>.

그러므로 내 컴퓨터가 사용하는 IP주소 165.132.120.10 이 속한 네트워크는 165.132.120.0 ~ 165.132.123.255 이다.

# 7. 학습 내용에 대한 개인적인 총평

network에 대해 ipaddres대해 피신이 시작되기 전에 공부햇을떄는 이해하기 어려운 부분이 많이 있었는데, 
먼저 진도를 나간 1기 1차 분들과 1기 2차분들이 정리해준 자료들과 인터넷에서 검색한 데이터들을 읽다보니, 빠르게 이해를 할수 있엇다. 만족스러운 학습이엿다. 

# 8. 다음 학습 계획

공부할것... >>> net what 공부하기.
netwhat 아직 덜해서 공부마무리하고 빨리시험 치기. 
