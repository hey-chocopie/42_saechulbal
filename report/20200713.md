# 1. 학습 날짜

* 2020-07-13(월)

# 2. 학습시간

* 17:00 ~ 22:00(이노베이션 아카데임 클러스터)

# 3. 학습 범위 및 주제

* libft bonus 파트의 함수 구현.

* ft_lstmap문제를 풀기 위한 포인터 정리
# 4. 동료 학습 방법

해당 사항 없음.

# 5. 학습 목표

* libft 를 풀기위한 기초지식을 습득하고 습득한 지식을 통해 프로그램 개발

# 6. 과제 제출 repository 주소

* 해당사항 없음 

# 7. 상세 학습 내용

* 실제 코딩에 사용한 시간: 3시간


* 구조체의 이중포인터를 사용하다 보니,포인터의 개념에 대해 한번더 정리해야할거라 생각이 들었다. 
  ![Alt text](https://dojang.io/pluginfile.php/342/mod_page/content/18/unit34-25.png)

  이런 식으로 이중포인터가 존재할떄 

  > *numptr1은 numptr에서 한번의 역참조가 진행이 되므로 *numPtr1으로 가게 되고 

  > numptr 에서 두번의 ** 역참좍 진행이 되면 num1으로 가게 되어 10이라는 값이 나오게 된다.
 numptr1은  메모리의 주소값이 담겨있다.


* 이중포인터의 배열형식
  ![Alt text](https://dojang.io/pluginfile.php/383/mod_page/content/22/unit38-3.png)
  > 이중포인터는 결국 주소를 가지고 역참조를 하는것이기 떄문에, 저장된 주소값에 인트값을 더해주게 된다면, 연결된 다른 배열들을 가지고 올수 있다. 

 * 이런식으로 이중포인터를 배열로 이용하는 방법왜에도, 메인 함수에서 자식 함수에 대한 기록을 저장할떄 메모리값을 저장하는 용도로 사용이된다. 

     
    <pre><code>void ft_lstiter(t_list *lst, void (*f)(void *)); 
    int main {
        ft_lstiter(lst, &f);
    }</code></pre>
    > 위와같은 코드가 존재할때 위와 같이 코드를 사용한다고 가정한다면 *lst에서 구조체에 대한 값은 저장을 할수 있지만, lst에 대한 값은 자식함수에서 변경할수 없다. 이유는 여기서 주소값에 대한 값을 변경하게 된다면 lst에 저장되어잇던 주소값에 의미를 잃어버리기 떄문이다. 메인문으로 돌아가면 원래의 주소값으로 변환되게  된다. 

# 8. 다음 학습 계획 
  * get_next_line의 문제의 이해. 및 설계